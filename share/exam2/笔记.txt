moduleid chunkid生成时机在哪，生成规则
事件流程， 每个事件做了啥
自定义插件干扰时间执行流程
loader，识别位置 作用时机
plugin，识别位置作用 作用时机
compile complication 作用 

entry 入口，webpack执行构建的第一步是从entry开始的，可以抽象成输入
module 模块，在webpack中一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始，递归找出所有依赖的模块
chunk 代码块，一个chunk是由多个模块组合而成，用于代码的-合并和分割
loader 模块转换器，用于将模块的原内容按照需求转换为新的内容
plugin 扩展插件，在webpack构建流程中的特定时机广播对应的事件，插件可以监听这些事件的发生，在特定的时机做对应的事情

webpack的运行过程是一个串行的过程，从启动到结束会依次执行以下流程
初始化参数：从配置文件和shell语句中读取与合并参数，得出最终的参数
开始编译：用上一步得到的参数初始化compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译
确定入口：根据配置中的entry找出所有的入口文件
编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
完成模块编译：在经过第4步使用loader翻译完所有模块后，得到了每个模块翻译后的最终内容以及他们之间的依赖关系
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表，这是可以修改输出内容的最后机会
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中

webpack会在特定的时间点广播特定的事件，插件在监听到感兴趣的事件之后会执行特定的逻辑，并且插件可以调用webpack提供的Api改变webpack的运行结果

webpack的构建流程可以分为一下三大阶段
初始化：启动构建，读取与合并配置参数，加载plugin，实例化compiler
编译：从entry发出，针对每个module串行调用对应的loader去翻译文件的内容，再找到该module依赖的module，递归地进行编译处理
输出：将编译后的module组合成chunk，将chunk转换成文件，输出到文件系统

webpack每一次的构建都会执行一遍上面的流程

1. 初始化阶段
1）初始化参数
从配置文件和shell语句中读取与合并参数，得出最终的参数，这个过程中还会执行配置文件中插件实例化语句new plugin()



2) 实例化compiler 
使用上一步初始化的配置实例化Compiler实例,Compiler负责文件的启动编译，在Compiler实例中包含完成的webpack配置，全局只存在一个Compiler实例
3）加载插件
依次调用插件的apply方法，让插件可以监听后续的所有事件节点，同时向插件传入compiler实例的引用，以方便插件通过compiler调用webpack提供的API
4）environment
开始应用node.js风格的文件系统到compiler对象，以方便后续的文件寻找和读取
5）entry-option
读取配置的entrys，为每个entry实例化一个对应的entryPlugin，为后面该entry递归解析工作做准备
6）after-plugins 
调用完所有的内置的和配置的插件的apply方法
7）after-resolvers
根据配置初始化resolver，resolver负责在文件系统中寻找制定路径的文件

argv保存 当前命令行的执行参数
option 保存着配置行文件中的配置信息


2.编译阶段
1) run 
启动一次新的编译





docker 保证安装版本和全局版本一致？？ 
docker 前端化
